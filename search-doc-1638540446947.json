[{"title":"Keyboard","type":0,"sectionRef":"#","url":"api/Keyboard","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#functions","content":" "},{"title":"AreAllKeysDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#AreAllKeysDown","content":"&lt;/&gt; Keyboard.AreAllKeysDown(...: EnumItem) → boolean A method which returns a boolean indicating if all keys in ... are held down.  "},{"title":"AreAnyKeysDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#AreAnyKeysDown","content":"&lt;/&gt; Keyboard.AreAnyKeysDown(...: EnumItem) → boolean A method which returns a boolean indicating if any keys in ... are held down.  "},{"title":"IsKeyDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#IsKeyDown","content":"&lt;/&gt; Keyboard.IsKeyDown(keycode: EnumItem) → boolean A method which returns a boolean indicating if keycode is held down. "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"OnValueUpdate","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#OnValueUpdate","content":"This item is read only and cannot be modified. Read Only ClientRemoteProperty &lt;/&gt; ClientRemoteProperty.OnValueUpdate: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the client remote property is updated, either on the client or on the server for the client, if the client remote property is bound to the server (a serverside remote property). "},{"title":"Functions","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#IsA","content":"&lt;/&gt; ClientRemoteProperty.IsA(self: any) → boolean A method which returns a boolean indicating if self is a client remote property or not.  "},{"title":"new","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#new","content":"&lt;/&gt; ClientRemoteProperty.new(currentValue: any) → ClientRemoteProperty Creates and returns a new client remote property.  "},{"title":"IsBoundToServer","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#IsBoundToServer","content":"ClientRemoteProperty &lt;/&gt; ClientRemoteProperty:IsBoundToServer() → boolean Returns a boolean indicating if the client remote property is bound to a server remote property.  "},{"title":"Destroy","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Destroy","content":"ClientRemoteProperty &lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the client remote property, renders it unusable and cleans up everything. note You should only ever destroy the client remote property once you're completely done working with it to avoid unexpected behavior.  "},{"title":"SetValue","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#SetValue","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields ClientRemoteProperty &lt;/&gt; ClientRemoteProperty:SetValue(newValue: any) → () Sets the value of the client remote property to newValue. If the client remote property is bound to a serverside remote property, then it will ask that remote property to set the value for the client to newValue.  "},{"title":"GetValue","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#GetValue","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields ClientRemoteProperty &lt;/&gt; ClientRemoteProperty:GetValue() → any Returns the value of the client remote property. If bound to the server (a serverside remote property), then it will retrieve the value of the client from that serverside remote property and if there is no value set specifically for the client, then it will return the current value of that serverside remote property.  "},{"title":"GetSpecificValue","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#GetSpecificValue","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields ClientRemoteProperty &lt;/&gt; ClientRemoteProperty:GetSpecificValue() → any This method is slighly different from ClientRemoteProperty:GetValue. It returns the specific value (only) set for the client in the serverside remote property that this remote property is bound to. warning This method is illegal to call if the client remote property is not bound to the server (a serverside remote property). "},{"title":"NumberUtil","type":0,"sectionRef":"#","url":"api/NumberUtil","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#properties","content":" "},{"title":"e","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#e","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.e: number Known as Euler's number, is a mathematical constant approximately equal to 2.7182818284590.  "},{"title":"Tau","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Tau","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Tau: number The circle constant representing the ratio between circumference and radius. The constant is equal to math.pi * 2 approximately.  "},{"title":"Phi","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Phi","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Phi: number An irrational number which is often known as the golden ratio or the most beautiful number in maths. "},{"title":"Functions","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#functions","content":" "},{"title":"Lerp","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Lerp","content":"&lt;/&gt; NumberUtil.Lerp( number: number, goal: number, alpha: number ) → number Smoothly interpolates number to goal, with alpha .  "},{"title":"QuadraticLerp","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#QuadraticLerp","content":"&lt;/&gt; NumberUtil.QuadraticLerp( number: number, goal: number, alpha: number ) → number Same as NumberUtil.Lerp, except the lerp is quadratic.  "},{"title":"InverseLerp","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#InverseLerp","content":"&lt;/&gt; NumberUtil.InverseLerp( min: number, max: number, alpha: number ) → number Inversely lerps min to goal, with alpha being the multiplier.  "},{"title":"Map","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Map","content":"&lt;/&gt; NumberUtil.Map( number: number, inMin: number, inMax: number, outMin: number, outMax: number ) → number Maps number between inMin, inMax, outMin and outMax.  "},{"title":"Round","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Round","content":"&lt;/&gt; NumberUtil.Round( number: number, to: number ) → number Rounds number to to.  "},{"title":"IsNaN","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#IsNaN","content":"&lt;/&gt; NumberUtil.IsNaN(number: number) → boolean Returns a boolean if the provided number is NaN (Not a Number).  "},{"title":"AreClose","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#AreClose","content":"&lt;/&gt; NumberUtil.AreClose( number: number, to: number, eplison: number? ) → boolean Returns a boolean if the provided number is close to to under eplision (or the default eplison i.e 1e-5). print(0.1 + 0.2 == 0.3) --&gt; false (due to floating point imprecision) print(NumberUtil.AreClose(0.1 + 0.2, 0.3)) --&gt; true   "},{"title":"Root","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Root","content":"&lt;/&gt; NumberUtil.Root( number: number, root: number ) → number Returns the &quot;root&quot; of number. print(NumberUtil.Root(2, 2)) --&gt; 1.4142135623731 (Square root) print(NumberUtil.Root(2, 3)) --&gt; 1.2599210498949 (Cube root) print(NumberUtil.Root(2, 4)) --&gt; 1.1892071150027 (Fourth root)   "},{"title":"Factorial","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Factorial","content":"&lt;/&gt; NumberUtil.Factorial(number: number) → number Returns the factorial of number.  "},{"title":"Factors","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Factors","content":"&lt;/&gt; NumberUtil.Factors(number: number) → table Returns all the factors of number.  "},{"title":"IsInfinite","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#IsInfinite","content":"&lt;/&gt; NumberUtil.IsInfinite(number: number) → boolean Returns a boolean indicating if number is infinite i.e math.huge. "},{"title":"UserInput","type":0,"sectionRef":"#","url":"api/UserInput","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"UserInput","url":"api/UserInput#properties","content":" "},{"title":"OnInputTypeChange","type":1,"pageTitle":"UserInput","url":"api/UserInput#OnInputTypeChange","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; UserInput.OnInputTypeChange: Signal&lt;newInputType: string&gt; A signal which is fired whenever the input type of the client changes. The new input type will be a string which will always be a member of UserInput.InputType.  "},{"title":"Mouse","type":1,"pageTitle":"UserInput","url":"api/UserInput#Mouse","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; UserInput.Mouse: table The required mouse module.  "},{"title":"Keyboard","type":1,"pageTitle":"UserInput","url":"api/UserInput#Keyboard","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; UserInput.Keyboard: table The required keyboard module.  "},{"title":"InputType","type":1,"pageTitle":"UserInput","url":"api/UserInput#InputType","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; UserInput.InputType: table A dictionary of input types. InputTypes Keyboard Mouse Gamepad Touch  "},{"title":"Functions","type":1,"pageTitle":"UserInput","url":"api/UserInput#functions","content":" "},{"title":"GetInputType","type":1,"pageTitle":"UserInput","url":"api/UserInput#GetInputType","content":"&lt;/&gt; UserInput.GetInputType() → string Returns the current input type of the client which will always be a member of UserInput.InputType. "},{"title":"Signal","type":0,"sectionRef":"#","url":"api/Signal","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Signal","url":"api/Signal#properties","content":" "},{"title":"ConnectionCount","type":1,"pageTitle":"Signal","url":"api/Signal#ConnectionCount","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; Signal.ConnectionCount: number The number of active connections. "},{"title":"Functions","type":1,"pageTitle":"Signal","url":"api/Signal#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"Signal","url":"api/Signal#IsA","content":"&lt;/&gt; Signal.IsA(self: any) → boolean A method which returns a boolean indicating if self is a signal or not.  "},{"title":"new","type":1,"pageTitle":"Signal","url":"api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Creates and returns a new signal.  "},{"title":"Connect","type":1,"pageTitle":"Signal","url":"api/Signal#Connect","content":"Signal &lt;/&gt; Signal:Connect(callback: function) → Connection Connects callback to the signal so that it will be called when Signal:Fire or Signal:DeferredFire are called, and the arguments passed to them will be passed to callback. This method returns a connection which contains the following methods: Methods Description Disconnect The connection will be disconnected. IsConnected Returns a boolean indicating if the connection is connected or not.   "},{"title":"CleanupConnections","type":1,"pageTitle":"Signal","url":"api/Signal#CleanupConnections","content":"Signal &lt;/&gt; Signal:CleanupConnections() → () Disconnects all connections created through Signal:Connect. note Threads yielded under signal:Wait will be disregarded if this method is called and thus will not be resumed when signal:Fire is called. For e.g: local signal = Signal.new() task.spawn(function() print(signal:Wait()) -- infinite yield end) signal:CleanupConnections() signal:Fire()   "},{"title":"Destroy","type":1,"pageTitle":"Signal","url":"api/Signal#Destroy","content":"Signal &lt;/&gt; Signal:Destroy() → () Destroys the signal, renders it unusuable and cleans up everything.  "},{"title":"Wait","type":1,"pageTitle":"Signal","url":"api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields Signal &lt;/&gt; Signal:Wait() → ... Yields the current Luau thread until the signal is fired through Signal:Fire or Signal:DeferredFire. All arguments passed to those methods (which were called) will be returned by this method.  "},{"title":"Fire","type":1,"pageTitle":"Signal","url":"api/Signal#Fire","content":"Signal &lt;/&gt; Signal:Fire(...: any) → () Resumes any yielded threads and calls every connected connection's callback passing in ... as the argument.  "},{"title":"DeferredFire","type":1,"pageTitle":"Signal","url":"api/Signal#DeferredFire","content":"Signal &lt;/&gt; Signal:DeferredFire(...: any) → () Works the same as Signal:Fire, but calls every connected connection's callback in the next engine execution step, passing in ... as the argument. "},{"title":"Timer","type":0,"sectionRef":"#","url":"api/Timer","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Timer","url":"api/Timer#properties","content":" "},{"title":"Boost","type":1,"pageTitle":"Timer","url":"api/Timer#Boost","content":"This item is read only and cannot be modified. Read Only Timer &lt;/&gt; Timer.Boost: number A value which by default is 0. This value is added to the delta time of every approximate frame the timer is updated (or if an update signal was specified, which in case the number fired to the custom update signal). Increasing it will lead to faster timer updates. local timer = Timer.new(5) timer.Boost = 4 timer:Start() timer.OnTick:Connect(function(deltaTime) print(deltaTime) --&gt; 8 (approx) end)   "},{"title":"OnTick","type":1,"pageTitle":"Timer","url":"api/Timer#OnTick","content":"This item is read only and cannot be modified. Read Only Timer &lt;/&gt; Timer.OnTick: Signal&lt;deltaTime: number&gt; A signal which is fired whenever the timer &quot;ticks&quot; (when started). timer.OnTick:Connect(function(deltaTime) warn((&quot;After %d seconds, tick!&quot;):format(deltaTime)) end) timer:Start()  "},{"title":"Functions","type":1,"pageTitle":"Timer","url":"api/Timer#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"Timer","url":"api/Timer#IsA","content":"&lt;/&gt; Timer.IsA(self: any) → boolean A method which returns a boolean indicating if self is a timer or not.  "},{"title":"new","type":1,"pageTitle":"Timer","url":"api/Timer#new","content":"&lt;/&gt; Timer.new( timer: number?, updateSignal: RBXScriptSignal? ) → Timer Creates and returns a new timer. If timer is not specified, it will default to 0 i.e the timer will be updated every frame. If updateSignal is not specified, it will default to RunService.Heartbeat. note If updateSignal is specified, it must be fired with a number as the first argument so that the timer is updated based on that number. For e.g: local updateSignal = Instance.new(&quot;BindableEvent&quot;) local timer = Timer.new(5, updateSignal.Event) while true do -- The timer will be updated by exactly 5 seconds every approx second: updateSignal:Fire(5) task.wait(1) end   "},{"title":"Reset","type":1,"pageTitle":"Timer","url":"api/Timer#Reset","content":"Timer &lt;/&gt; Timer:Reset() → () Resets the timer.  "},{"title":"Start","type":1,"pageTitle":"Timer","url":"api/Timer#Start","content":"Timer &lt;/&gt; Timer:Start() → () Starts the timer.  "},{"title":"IsStarted","type":1,"pageTitle":"Timer","url":"api/Timer#IsStarted","content":"Timer &lt;/&gt; Timer:IsStarted() → boolean Returns a boolean indicating if the timer has started.  "},{"title":"Pause","type":1,"pageTitle":"Timer","url":"api/Timer#Pause","content":"Timer &lt;/&gt; Timer:Pause() → () Pauses the timer.  "},{"title":"Unpause","type":1,"pageTitle":"Timer","url":"api/Timer#Unpause","content":"Timer &lt;/&gt; Timer:Unpause() → () Unpauses the timer.  "},{"title":"IsPaused","type":1,"pageTitle":"Timer","url":"api/Timer#IsPaused","content":"Timer &lt;/&gt; Timer:IsPaused() → boolean Returns a boolean indicating if the timer has being paused.  "},{"title":"Destroy","type":1,"pageTitle":"Timer","url":"api/Timer#Destroy","content":"Timer &lt;/&gt; Timer:Destroy() → () Destroys the timer, renders it unusuable and cleans up everything.  "},{"title":"Stop","type":1,"pageTitle":"Timer","url":"api/Timer#Stop","content":"Timer &lt;/&gt; Timer:Stop() → () Stops the timer. "},{"title":"TableUtil","type":0,"sectionRef":"#","url":"api/TableUtil","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#functions","content":" "},{"title":"DeepFreeze","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#DeepFreeze","content":"&lt;/&gt; TableUtil.DeepFreeze(tabl: table) → () Freezes all keys and values in tabl via table.freeze, as well as in all other nested tables in tabl.  "},{"title":"DeepCopy","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#DeepCopy","content":"&lt;/&gt; TableUtil.DeepCopy(tabl: table) → table Returns a deep copy of tabl, also accounting for nested keys and values.  "},{"title":"ShallowCopy","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#ShallowCopy","content":"&lt;/&gt; TableUtil.ShallowCopy(tabl: table) → table Works the same as TableUtil.DeepCopy, but doesn't account for nested keys and values.  "},{"title":"Reconcile","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reconcile","content":"&lt;/&gt; TableUtil.Reconcile( tabl: table, templateTable: table ) → () Adds all missing elements from templateTable to tabl. local t1 = {} local templateTable = {1, 2, 3} TableUtil.Reconcile(t1, templateTable) print(t1) --&gt; {1,2,3}   "},{"title":"Shuffle","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Shuffle","content":"&lt;/&gt; TableUtil.Shuffle( tabl: table, randomObject: Random? ) → () Shuffles tabl such that the indices will have values of other indices in tabl in a random way. If randomObject is specified, it will be used instead to shuffle tabl. note This method assumes that tabl is an array with no holes. local t1 = {1, 2, 3, 4, 5} TableUtil.Shuffle(t1) print(t1) --&gt; {3, 2, 4, 5, 1, 6}   "},{"title":"IsEmpty","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#IsEmpty","content":"&lt;/&gt; TableUtil.IsEmpty(tabl: table) → boolean Returns a boolean indicating if tabl is completely empty.  "},{"title":"Map","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Map","content":"&lt;/&gt; TableUtil.Map( tabl: table, callback: function ) → () Performs a map against tabl, which can be used to map new values based on the old values at given indices. local t = {1, 2, 3, 4, 5} TableUtil.Map(t, function(key, value) return value * 2 end) print(t2) --&gt; {2, 4, 6, 8, 10}   "},{"title":"Combine","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Combine","content":"&lt;/&gt; TableUtil.Combine(...: table) → table A method which combines all tables ... into 1 single mega table. local t = {1, 2, 3, 4, 5} local t1 = {7, 8, 9} local t2 = {10, 11, 12} local combinedTable = TableUtil.Combine(t, t1, t2) print(combinedTable) --&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}   "},{"title":"Empty","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Empty","content":"&lt;/&gt; TableUtil.Empty(tabl: table) → () Clears out all keys in tabl. local t = {1, 2, 3, 4, 5} TableUtil.Empty(t) print(t) --&gt; {}   "},{"title":"Reverse","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reverse","content":"&lt;/&gt; TableUtil.Reverse(tabl: table) → () A method which reverses tabl. note This method assumes that tabl is an array with no holes. local t = {1, 2, 3, 4, 5} TableUtil.Reverse(t) print(t) --&gt; {5, 4, 3, 2, 2, 1}   "},{"title":"GetElementCount","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#GetElementCount","content":"&lt;/&gt; TableUtil.GetElementCount(tabl: table) → number A method which returns a number of all the elements in tabl. local t = {1, 2, 3, 4, 5, a = 5, b = 6} print(TableUtil.GetElementCount(t)) --&gt; 7   "},{"title":"GetKeyFromValue","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#GetKeyFromValue","content":"&lt;/&gt; TableUtil.GetKeyFromValue( tabl: table, value: any ) → any? A method which returns the key in which value is stored at in tabl. local t = {a = 5, b = 10} print(TableUtil.GetKeyFromValue(t, 5)) --&gt; &quot;a&quot; note This method will not work well for different keys which have the same value, and doesn't account for nested key and values.  "},{"title":"AreEqual","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#AreEqual","content":"&lt;/&gt; TableUtil.AreEqual( tabl1: table, tabl2: table ) → boolean A method which checks if both tabl and otherTable are equal in terms of values. local t1 = {1, 2, 3, 4, 5, {a = 4}} local t2 = {1, 2, 3, 4, 5, {a = 3}} print(TableUtil.AreEqual(t1, t2)) --&gt; false local t1 = {1, 2, 3, 4, 5, {a = 4}} local t2 = {1, 2, 3, 4, 5, {a = 4}} print(TableUtil.AreEqual(t1, t2)) --&gt; true note This method works well on tables that contain only primitive values except for userdata and thread. This method also doesn't check keys. For e.g: local t = { [{}] = 5, } local b = { [{}] = 5, } print(TableUtil.AreEqual(t, b)) --&gt; false  "},{"title":"ClientCommunicationSignal","type":0,"sectionRef":"#","url":"api/ClientCommunicationSignal","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#properties","content":" "},{"title":"Members","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#Members","content":"This item is read only and cannot be modified. Read Only ClientCommunicationSignal &lt;/&gt; ClientCommunicationSignal.Members: table A dictionary of all members binded to the client communication signal.  "},{"title":"RemoteSignals","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#RemoteSignals","content":"This item is read only and cannot be modified. Read Only ClientCommunicationSignal &lt;/&gt; ClientCommunicationSignal.RemoteSignals: table A dictionary of all remote signals binded to the client communication signal.  "},{"title":"RemoteProperties","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#RemoteProperties","content":"This item is read only and cannot be modified. Read Only ClientCommunicationSignal &lt;/&gt; ClientCommunicationSignal.RemoteProperties: table A dictionary of all remote properties binded to the client communication signal. "},{"title":"Functions","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#functions","content":" "},{"title":"GetDispatchedCommunicationSignal","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#GetDispatchedCommunicationSignal","content":"&lt;/&gt; ClientCommunicationSignal.GetDispatchedCommunicationSignal( identifier: string, timeout: number? ) → Promise Returns a promise which is resolved with the serverside dispatched signal represented in a client communication signal.timeout will default to 3 if not specified and the method will wait for timeout seconds for the serverside dispatched signal to exist before assuming that it doesn't and rejecting with a nil value. -- On the server: local signal = CommunicationSignal.new(&quot;Signal&quot;) signal:Bind(&quot;bo&quot;, true) signal:DispatchToClient() -- On the client: ClientCommunicationSignal.GetDispatchedCommunicationSignal(&quot;Signal&quot;):andThen(function(signal) print(signal.Members.bo) --&gt; true end) tip This method returns cached results when retrieving the same dispatched communication signal, if it was successfully retrieved in the first place. For e.g: -- On the server: local signal = CommunicationSignal.new(&quot;Signal&quot;) signal:DispatchToClient() -- On the client: local clientSignal1 = ClientCommunicationSignal.GetDispatchedCommunicationSignal(&quot;Signal&quot;):expect() local clientSignal2 = ClientCommunicationSignal.GetDispatchedCommunicationSignal(&quot;Signal&quot;):expect() print(clientSignal1 == clientSignal2) --&gt; true   "},{"title":"IsA","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#IsA","content":"&lt;/&gt; ClientCommunicationSignal.IsA(self: any) → boolean A method which returns a boolean indicating if self is a client communication signal or not.  "},{"title":"Build","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#Build","content":"ClientCommunicationSignal &lt;/&gt; ClientCommunicationSignal:Build() → table A method which builds the communication signal for client-side use. For e.g: local builtSignal = clientCommunicationSignal:Build() -- Normally to access members you would do: print(clientSignal.Members.Table) --&gt; {1, 2, 3} -- Via dispatched signal: print(builtSignal.Table) --&gt; {1, 2, 3} tip This method returns cached results if the client communication signal was already previously built. For e.g: local s = clientCommunicationSignal:Build() local o = clientCommunicationSignal:Build() print(s == o) --&gt; true   "},{"title":"GetMethod","type":1,"pageTitle":"ClientCommunicationSignal","url":"api/ClientCommunicationSignal#GetMethod","content":"ClientCommunicationSignal &lt;/&gt; ClientCommunicationSignal:GetMethod(name: string) → function? A method which returns a binded method name to the client communication signal. For e.g: -- On the server: local signal = CommunicationSignal.new(&quot;Signal&quot;) signal:Bind(&quot;bo&quot;, function() end) signal:DispatchToClient() -- On the client: local clientSignal = ClientCommunicationSignal.GetDispatchedCommunicationSignal(&quot;Signal&quot;):expect() print(typeof(clientSignal:GetMethod(&quot;bo&quot;))) --&gt; function  "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#IsA","content":"&lt;/&gt; ClientRemoteSignal.IsA(self: any) → boolean A method which returns a boolean indicating if self is a client remote signal or not.  "},{"title":"new","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#new","content":"&lt;/&gt; ClientRemoteSignal.new() → ClientRemoteSignal Creates and returns a new client remote signal.  "},{"title":"IsBoundToServer","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#IsBoundToServer","content":"ClientRemoteSignal &lt;/&gt; ClientRemoteSignal:IsBoundToServer() → boolean Returns a boolean indicating if the client remote signal is bound to the server, i.e to some serverside remote signal.  "},{"title":"Connect","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connect","content":"ClientRemoteSignal &lt;/&gt; ClientRemoteSignal:Connect(callback: function) → RBXScriptConnection Same as self._remote:Connect(callback).  "},{"title":"Fire","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Fire","content":"ClientRemoteSignal &lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Same as self._remote:FireServer(...).  "},{"title":"Destroy","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Destroy","content":"ClientRemoteSignal &lt;/&gt; ClientRemoteSignal:Destroy(...: any) → () Destroys the client remote signal, renders it unusuable and cleans up everything. note You should only ever destroy the client remote signal once you're completely done working with it to avoid unexpected behavior.  "},{"title":"CleanupConnections","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#CleanupConnections","content":"ClientRemoteSignal &lt;/&gt; ClientRemoteSignal:CleanupConnections() → () Disconnects all connections created through ClientRemoteSignal:Connect.  "},{"title":"Wait","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ClientRemoteSignal:Wait() → ... A method which yields the thread until the remote signal (that this client remote signal is bound to) is fired on the server. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally based workflow","type":1,"pageTitle":"Installation","url":"docs/intro#wally-based-workflow","content":"To retrieve any packages through this workflow, Wally is required. Package\tDependency\tDescriptionNumberUtil\t&quot;finobinos/numberutil@1.1.5&quot;\tNumberUtil UserInput\t&quot;finobinos/userinput@1.3.0&quot;\tUserInputUtil TableUtil\t&quot;finobinos/tableutil@1.1.6&quot;\tTableUtil Maid\t&quot;finobinos/Maid@1.2.3&quot;\tMaid class Timer\t&quot;finobinos/timer@1.2.8&quot;\tTimer class Signal\t&quot;finobinos/signal@1.2.2\tSignal class Remote\t&quot;finobinos/remote@1.3.4&quot;\tRemoteUtil Run wally init on your project's directory, and then add the various utility modules through the wally.toml file. For e.g, the following would be a wally.toml file for a project that needs a signal and a maid module: [package]name = &quot;finobinos/Project&quot;version = &quot;0.1.0&quot;registry = &quot;https://github.com/UpliftGames/wally-index&quot;realm = &quot;shared&quot; [dependencies]Signal = &quot;finobinos/signal@1.1.9&quot;Maid = &quot;finobinos/maid@1.2.3&quot; Copy These dependencies can be then installed to your project through wally install, which will create a folder Packages in your project containing the dependencies. The package folder created can then be synced into Roblox Studio through Rojo. The following default.project.json file would be used to sync the package folder into Roblox Studio: { &quot;name&quot;: &quot;Project&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } }} Copy "},{"title":"Roblox based workflow","type":1,"pageTitle":"Installation","url":"docs/intro#roblox-based-workflow","content":"You can retrieve the packages from here. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#IsA","content":"&lt;/&gt; RemoteSignal.IsA(self: any) → boolean A method which returns a boolean indicating if self is a remote signal or not.  "},{"title":"new","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#new","content":"&lt;/&gt; RemoteSignal.new() → RemoteSignal Creates and returns a new remote signal.  "},{"title":"IsBoundToClient","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#IsBoundToClient","content":"RemoteSignal &lt;/&gt; RemoteSignal:IsBoundToClient() → boolean Returns a boolean indicating if the remote signal is bound to the client.  "},{"title":"Destroy","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Destroy","content":"RemoteSignal &lt;/&gt; RemoteSignal:Destroy() → () Destroys the remote signal, renders it unusuable and cleans up everything. note You should only ever destroy the remote signal once you're completely done working with it to avoid unexpected behavior.  "},{"title":"Connect","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connect","content":"RemoteSignal &lt;/&gt; RemoteSignal:Connect() → RBXScriptConnection Works the same as self._remote:Connect(callback).  "},{"title":"CleanupConnections","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#CleanupConnections","content":"ClientRemoteSignal &lt;/&gt; RemoteSignal:CleanupConnections() → () Disconnects all connections created through RemoteSignal:Connect.  "},{"title":"FireClients","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireClients","content":"RemoteSignal &lt;/&gt; RemoteSignal:FireClients( clients: table, ...: any ) → () Works the same as self._remote:FireClient(player, ...), but for every player in the clients table. "},{"title":"Mouse","type":0,"sectionRef":"#","url":"api/Mouse","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Mouse","url":"api/Mouse#properties","content":" "},{"title":"OnLeftClick","type":1,"pageTitle":"Mouse","url":"api/Mouse#OnLeftClick","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.OnLeftClick: Signal&lt;isInputProcessed: boolean&gt; A signal fired whenever the user left clicks on their mouse.  "},{"title":"OnRightClick","type":1,"pageTitle":"Mouse","url":"api/Mouse#OnRightClick","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.OnRightClick: Signal&lt;isInputProcessed: boolean&gt; A signal fired whenever the user right clicks on their mouse.  "},{"title":"OnScrollClick","type":1,"pageTitle":"Mouse","url":"api/Mouse#OnScrollClick","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.OnScrollClick: Signal&lt;isInputProcessed: boolean&gt; A signal fired whenever the user scroll clicks on their mouse.  "},{"title":"OnMove","type":1,"pageTitle":"Mouse","url":"api/Mouse#OnMove","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.OnMove: Signal&lt;deltaPosition: Vector3&gt; A signal fired whenever the user moves their mouse.  "},{"title":"OnTargetChange","type":1,"pageTitle":"Mouse","url":"api/Mouse#OnTargetChange","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.OnTargetChange: Signal&lt;newTarget: Instance?&gt; A signal which is fired whenever Mouse.Target changes.  "},{"title":"TargetFilterType","type":1,"pageTitle":"Mouse","url":"api/Mouse#TargetFilterType","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.TargetFilterType: EnumItem By default, the value is Enum.RaycastFilterType.Blacklist. Used as the filter type in retrieving Mouse.Target and Mouse.Hit. note This member should only be set to Enum.RaycastFilterType.Blacklist or Enum.RaycastFilterType.Whitelist.  "},{"title":"Hit","type":1,"pageTitle":"Mouse","url":"api/Mouse#Hit","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.Hit: CFrame The CFrame the mouse hit in the 3D world.  "},{"title":"UnitRay","type":1,"pageTitle":"Mouse","url":"api/Mouse#UnitRay","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.UnitRay: Ray The unit ray from the mouse's 2D position to the 3D world.  "},{"title":"X","type":1,"pageTitle":"Mouse","url":"api/Mouse#X","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.X: number The X coordinate of the mouse's position on the screen.  "},{"title":"X","type":1,"pageTitle":"Mouse","url":"api/Mouse#X","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.X: number The Y coordinate of the mouse's position on the screen.  "},{"title":"Target","type":1,"pageTitle":"Mouse","url":"api/Mouse#Target","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.Target: Instance? The instance the mouse hit in the 3D world.  "},{"title":"Origin","type":1,"pageTitle":"Mouse","url":"api/Mouse#Origin","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Mouse.Origin: CFrame A CFrame at the camera's position, facing the 3D position of the mouse. Equivalent to CFrame.lookAt(Workspace.CurrentCamera.CFrame.Position, Mouse.Hit.Position). "},{"title":"Functions","type":1,"pageTitle":"Mouse","url":"api/Mouse#functions","content":" "},{"title":"GetDeltaPosition","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetDeltaPosition","content":"&lt;/&gt; Mouse.GetDeltaPosition() → Vector3 Returns the position of the mouse from the last frame to the current.  "},{"title":"CastRay","type":1,"pageTitle":"Mouse","url":"api/Mouse#CastRay","content":"&lt;/&gt; Mouse.CastRay( raycastParams: RaycastParams?, distance: number ) → RaycastResult? Casts a ray from the mouse's current position to it's position extended distance studs, respecting raycastParams if provided.  "},{"title":"LockToCurrentPosition","type":1,"pageTitle":"Mouse","url":"api/Mouse#LockToCurrentPosition","content":"&lt;/&gt; Mouse.LockToCurrentPosition() → () Locks the mouse to it's current position.  "},{"title":"Unlock","type":1,"pageTitle":"Mouse","url":"api/Mouse#Unlock","content":"&lt;/&gt; Mouse.Unlock() → () Unlocks the mouse.  "},{"title":"LockToCenter","type":1,"pageTitle":"Mouse","url":"api/Mouse#LockToCenter","content":"&lt;/&gt; Mouse.LockToCenter() → () Locks the mouse to the center.  "},{"title":"AddTargetFilter","type":1,"pageTitle":"Mouse","url":"api/Mouse#AddTargetFilter","content":"&lt;/&gt; Mouse.AddTargetFilter(targetFilter: Instance) → () Adds targetFilter to the filter list so that they will be filtered out when calculating Mouse.Hit and Mouse.Target.  "},{"title":"SetTargetFilterType","type":1,"pageTitle":"Mouse","url":"api/Mouse#SetTargetFilterType","content":"&lt;/&gt; Mouse.SetTargetFilterType(targetFilterType: EnumItem) → () Sets the filter type to targetFilterType which is used internally in filtering instances added through Mouse.AddTargetFilter when calculating Mouse.Hit and Mouse.Target. EnumItem Description Enum.RaycastFilterType.Whitelist Only the instance added through Mouse.AddTargetFilter will be respected. Enum.RaycastFilterType.Blacklist The instance added through Mouse.AddTargetFilter will be ignored. By default, the filter type is Enum.RaycastFilterType.Blacklist.  "},{"title":"RemoveTargetFilter","type":1,"pageTitle":"Mouse","url":"api/Mouse#RemoveTargetFilter","content":"&lt;/&gt; Mouse.RemoveTargetFilter(targetFilter: Instance) → () Removes targetFilter from the filter list so that it will not be filtered out when calculating Mouse.Hit and Mouse.Target. "},{"title":"CommunicationSignal","type":0,"sectionRef":"#","url":"api/CommunicationSignal","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#properties","content":" "},{"title":"Members","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#Members","content":"This item is read only and cannot be modified. Read Only CommunicationSignal &lt;/&gt; CommunicationSignal.Members: table A dictionary of all members binded to the communication signal.  "},{"title":"RemoteSignals","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#RemoteSignals","content":"This item is read only and cannot be modified. Read Only CommunicationSignal &lt;/&gt; CommunicationSignal.RemoteSignals: table A dictionary of all remote signals binded to the communication signal.  "},{"title":"RemoteProperties","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#RemoteProperties","content":"This item is read only and cannot be modified. Read Only CommunicationSignal &lt;/&gt; CommunicationSignal.RemoteProperties: table A dictionary of all remote properties binded to the communication signal. "},{"title":"Functions","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#functions","content":" "},{"title":"new","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#new","content":"&lt;/&gt; CommunicationSignal.new(identifier: string) → CommunicationSignal Creates and returns a new communication signal with the identifier of identifier.  "},{"title":"GetCommunicationSignal","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#GetCommunicationSignal","content":"&lt;/&gt; CommunicationSignal.GetCommunicationSignal(identifier: string) → CommunicationSignal Returns the communication signal of identifier identifier.  "},{"title":"IsA","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#IsA","content":"&lt;/&gt; CommunicationSignal.IsA(self: any) → boolean A method which returns a boolean indicating if self is a communication signal or not.  "},{"title":"Bind","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#Bind","content":"CommunicationSignal &lt;/&gt; CommunicationSignal:Bind( key: string, value: any ) → () Binds a new key key of value value to the client. note It is illegal to call this method if the communication signal is already dispatched to the client. Remote function limitations apply, see Remote Functions and Events.  "},{"title":"DispatchToClient","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#DispatchToClient","content":"CommunicationSignal &lt;/&gt; CommunicationSignal:DispatchToClient() → () Dispatches the communication signal to the client. Only call this method when the communication signal is ready to be exposed to the client.  "},{"title":"IsDispatchedToClient","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#IsDispatchedToClient","content":"CommunicationSignal &lt;/&gt; CommunicationSignal:IsDispatchedToClient() → boolean Returns a boolean indicating if the communication signal has been dispatched to the client.  "},{"title":"Destroy","type":1,"pageTitle":"CommunicationSignal","url":"api/CommunicationSignal#Destroy","content":"CommunicationSignal &lt;/&gt; CommunicationSignal:Destroy() → () Destroys the communication signal, renders it unusable and cleans up everything including bound remote signals and remote properties to the client (if they weren't destroyed yet). "},{"title":"Maid","type":0,"sectionRef":"#","url":"api/Maid","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Maid","url":"api/Maid#functions","content":" "},{"title":"new","type":1,"pageTitle":"Maid","url":"api/Maid#new","content":"&lt;/&gt; Maid.new() → Maid A constructor method which creates and returns a new maid.  "},{"title":"IsA","type":1,"pageTitle":"Maid","url":"api/Maid#IsA","content":"&lt;/&gt; Maid.IsA(self: any) → boolean A method which is used to check if the given argument is a maid or not.  "},{"title":"AddTask","type":1,"pageTitle":"Maid","url":"api/Maid#AddTask","content":"Maid &lt;/&gt; Maid:AddTask(task: function | RBXScriptConnection | table | Instance) → task Adds a task for the maid to cleanup. note If table is passed as a task, it must have a Destroy or Disconnect method so that it can be cleaned up.  "},{"title":"RemoveTask","type":1,"pageTitle":"Maid","url":"api/Maid#RemoveTask","content":"Maid &lt;/&gt; Maid:RemoveTask(task: task) → () Removes the task so that it will not be cleaned up when the maid is cleaning up added tasks. For e.g: local task = function() end maid:AddTask(task) -- Okay, i just dont want task to be cleaned up anymore, redundant: maid:RemoveTask(task) maid:Cleanup() -- (nothing, the added task wasn't cleaned up as we removed it just after it was added, lol!)   "},{"title":"Cleanup","type":1,"pageTitle":"Maid","url":"api/Maid#Cleanup","content":"Maid &lt;/&gt; Maid:Cleanup() → () Cleans up all the added tasks. Task Cleanup procedure function The function will be called. table Any Destroy or Disconnect method in the table will be called. Instance The instance will be destroyed. RBXScriptConnection The connection will be disconnected.   "},{"title":"Destroy","type":1,"pageTitle":"Maid","url":"api/Maid#Destroy","content":"Maid &lt;/&gt; Maid:Destroy() → () Destroys the maid and renders it unusuable and cleans up all added tasks. Also unlinks the maid from all instances it was linked to. For e.g: local _, connection = maid:LinkToInstance(instance) print(connection:IsConnected()) --&gt; true maid:Destroy() print(connection:IsConnected()) --&gt; false   "},{"title":"LinkToInstance","type":1,"pageTitle":"Maid","url":"api/Maid#LinkToInstance","content":"&lt;/&gt; Maid:LinkToInstance( instance: Instance, callback: function? ) → ( Instance, Connection ) Links the given instance to the maid so that the maid will be destroyed once the instance has been removed from the game i.e parented to nil. If callback is specified, it will be called before destroying the maid (when the instance is parented to nil) and if the function upon being called doesn't return a truthy value, the maid will not be destroyed. For e.g: local instance = ... -- some instance parented to workspace local maid = Maid.new() maid:AddTask(function() warn(&quot;cleaned up&quot;) end) maid:LinkToInstance(instance) instance.Parent = nil -- Now the maid will cleanup as the instance is parented to nil. Here's an alternate case: local instance = ... -- some instance parented to workspace local maid = Maid.new() maid:AddTask(function() warn(&quot;cleaned up&quot;) end) maid:LinkToInstance(instance, function() return not instance:GetAttribute(&quot;DontHaveTheMaidCleanedupYetPlease&quot;) end)) instance:SetAttribute(&quot;DontHaveTheMaidCleanedupYetPlease&quot;, true) instance.Parent = nil -- The instance is parented to nil, but the maid hasn't cleaned up! A connection is returned so that once it is disconnected, the maid will unlink from the instance, which contains the following methods: Methods Description Disconnect The connection will be disconnected and the maid will unlink to the instance it was linked to. IsConnected Returns a boolean indicating if the connection has been disconnected.  "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#properties","content":" "},{"title":"OnValueUpdate","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#OnValueUpdate","content":"This item is read only and cannot be modified. Read Only RemoteProperty &lt;/&gt; RemoteProperty.OnValueUpdate: Signal&lt;newValue: any&gt; A signal which is fired whenever the value stored in the remote property is updated to a new one. remoteProperty.OnValueUpdate:Connect(function(newValue) print((&quot;Value was updated to %s&quot;):format(tostring(newValue))) end)   "},{"title":"OnClientValueUpdate","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#OnClientValueUpdate","content":"This item is read only and cannot be modified. Read Only RemoteProperty &lt;/&gt; RemoteProperty.OnClientValueUpdate: Signal&lt;client: Player,newValue: any&gt; A signal which is fired whenever the value of a client is updated to a new one. remoteProperty.OnClientValueUpdate:Connect(function(client, newValue) print((&quot;%s's value was updated to %s&quot;):format(client.Name, tostring(newValue))) end)  "},{"title":"Functions","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"IsA","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#IsA","content":"&lt;/&gt; RemoteProperty.IsA(self: any) → boolean A method which returns a boolean indicating if self is a remote property or not.  "},{"title":"new","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new( initialValue: any, clientValueSetValidatorCallback: function? ) → RemoteProperty Creates and returns a new remote property, with the initial value of the remote property being initialValue. clientValueSetValidatorCallback can be a function which will be run when a client requests to set their value to something they desire, if this remote property is binded to the client through a communication signal. For e.g: -- On the server local remoteProperty = RemoteProperty.new(3, function(client, valueTheyWantToSet) if IsValueValid(valueTheyWantToSet) then return true end end) -- On the client: local clientRemoteProperty = ... -- This will tell the serverside remote property to set the value of the client to 50 by first -- calling the onServerInvokeCallback and if it returns true, then the remote property sets the value -- of the client to 50. If onServerInvokeCallback is not specified, then this won't work. clientRemoteProperty:SetValue(50)   "},{"title":"IsBoundToClient","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#IsBoundToClient","content":"RemoteProperty &lt;/&gt; RemoteProperty:IsBoundToClient() → boolean Returns a boolean indicating if the remote property is bound to the client.  "},{"title":"Destroy","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Destroy","content":"RemoteProperty &lt;/&gt; RemoteProperty:Destroy() → () Destroys the remote property, renders it unusable and cleans up everything. note You should only ever destroy the remote property once you're completely done working with it to avoid unexpected behavior.  "},{"title":"SetValue","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetValue","content":"RemoteProperty &lt;/&gt; RemoteProperty:SetValue( newValue: any, clients: ? ) → () Sets the value of the remote property to newValue. If the remote property is bound to the client, then it will update the value for every player to newValue and their client remote property (the one that is bound to this remote property) to newValue as well and also updates the current value of the remote property to newValue. If clients is specified, then the value will only be updated for each player in the clients table. note Each client's specific value set in the remote property will be flushed (cleared out) when they leave. warning It is illegal to set the value for clients only if the remote property isn't bound to the client.  "},{"title":"GetValue","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#GetValue","content":"RemoteProperty &lt;/&gt; RemoteProperty:GetValue(client: Player?) → any Returns the current value of the remote property. If client is specified, then it will return the specific value set for client in the remote property. "}]