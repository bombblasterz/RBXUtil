"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[101],{98217:function(n){n.exports=JSON.parse('{"functions":[{"name":"IsA","desc":"A method which returns a boolean indicating if `self` is a signal or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":69,"path":"packages/Signal/init.lua"}},{"name":"new","desc":"Creates and returns a new signal.","params":[],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":79,"path":"packages/Signal/init.lua"}},{"name":"Connect","desc":"Connects `callback` to the signal so that it will be called when `Signal:Fire` or `Signal:DeferredFire` are called, and the arguments\\npassed to them will be passed to `callback`. This method returns a connection which contains the following methods:\\n\\n| Methods      | Description                          |\\n| ----------- | ------------------------------------ |\\n| `Disconnect`  | The connection will be disconnected and `callback` will be disregarded. |\\n| `IsConnected` | Returns a boolean indicating if the connection has been disconnected. |","params":[{"name":"callback","desc":"","lua_type":"function"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","tags":["Signal"],"source":{"line":159,"path":"packages/Signal/init.lua"}},{"name":"DisconnectConnections","desc":"Disconnects all connections.","params":[],"returns":[],"function_type":"method","tags":["Signal"],"source":{"line":183,"path":"packages/Signal/init.lua"}},{"name":"Destroy","desc":"Destroys the signal and renders it unusuable.","params":[],"returns":[],"function_type":"method","tags":["Signal"],"source":{"line":199,"path":"packages/Signal/init.lua"}},{"name":"Wait","desc":"Yields the current Luau thread until the signal is fired through `Signal:Fire` or `Signal:DeferredFire`. All \\narguments passed to those methods (which were called) will be returned by this method.\\n\\n:::tip \\nAny threads yielded through this method will be automatically resumed with a `nil` value once the signal\\nis destroyed, to prevent memory leaks.\\n\\nFor e.g:\\n\\n```lua\\nlocal s = Signal.new()\\n\\ntask.spawn(function()\\n\\tprint(s:Wait()) --\x3e nil\\nend)\\n\\ns:Destroy()\\n```\\n:::\\n\\n```lua\\nlocal s = Signal.new()\\n\\ntask.spawn(function()\\n\\tprint(s:Wait()) --\x3e \\"yoooooo\\"\\nend)\\n\\ns:Fire(\\"yoooooo\\")\\n```","params":[],"returns":[{"desc":"","lua_type":"..."}],"function_type":"method","tags":["Signal"],"yields":true,"source":{"line":246,"path":"packages/Signal/init.lua"}},{"name":"Fire","desc":"Resumes any yielded threads and calls every connection\'s callback passing in `...` as the argument.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["Signal"],"source":{"line":271,"path":"packages/Signal/init.lua"}},{"name":"DeferredFire","desc":"Works the same as `Signal:Fire`, but calls every connection\'s callback **in the next engine execution step**, passing in `...` as the argument.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["Signal"],"source":{"line":282,"path":"packages/Signal/init.lua"}}],"properties":[{"name":"ConnectionCount","desc":"The number of active connections.","lua_type":"number","tags":["Signal"],"readonly":true,"source":{"line":53,"path":"packages/Signal/init.lua"}}],"types":[],"name":"Signal","desc":"In layman\'s terms, signals dispatch events with necessary information.\\n\\nHere\'s an example use case for them:\\n\\n```lua\\nlocal signal = Signal.new()\\n\\nsignal:Connect(function(data)\\n\\tprint(data) --\x3e \\"Signals dispatch information like this one!\\"\\nend\\n\\nsignal:Fire(\\"Signals dispatch information like this one!\\")\\n```","source":{"line":44,"path":"packages/Signal/init.lua"}}')}}]);