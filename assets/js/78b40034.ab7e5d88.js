"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4189],{82155:function(e){e.exports=JSON.parse('{"functions":[{"name":"RegisterComponentsIn","desc":"Registers all the module scripts in `componentsFolder`, so that \\nthe table returned from each module script will be binded to a new component.\\n\\n:::note\\nDescendants will be ignored. However, folders will be accounted for, as well as nested folders.\\n:::","params":[{"name":"componentsFolder","desc":"","lua_type":"Folder"}],"returns":[],"function_type":"static","source":{"line":190,"path":"packages/Component/init.lua"}},{"name":"IsA","desc":"Returns a boolean indicating if `self` is a component or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":227,"path":"packages/Component/init.lua"}},{"name":"GetAll","desc":"Returns an array of all components.","params":[],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":237,"path":"packages/Component/init.lua"}},{"name":"GetFromTags","desc":"Returns a component from `tags`.\\n\\nFor e.g:\\n\\n```lua\\nlocal class = {}\\nclass.Tags = {\\"1\\"}\\n---\\n\\nComponent.new(class)\\nprint(Component.GetFromTags(class.Tags)) --\x3e {...} (class)\\n```","params":[{"name":"tags","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"Component ?"}],"function_type":"static","source":{"line":259,"path":"packages/Component/init.lua"}},{"name":"GetFromName","desc":"Returns a component of `name`, if found.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Component ?"}],"function_type":"static","source":{"line":281,"path":"packages/Component/init.lua"}},{"name":"GetServerComponent","desc":"Returns a promise which is resolved once a  serverside component `serverComponentName` is found or rejected if not found.\\n\\n:::note\\nThe serverside component retrieved must have a `Client` table, or the method will assume it doesn\'t exist even if \\nactually does.\\n:::\\n\\nExample client component interacting with a server component:\\n\\n```lua\\n-- Client component\\nlocal Block = {Name = \\"Block\\", Tags = {\\"Block\\"}}\\n\\nlocal BlockServer\\n\\nfunction Block.Init()\\n\\tBlockServer = Block.Component.GetServerComponent(\\"BlockServer\\"):expect()\\nend\\n\\nfunction Block.new(instance)\\n\\tprint(BlockServer.Block(instance)) --\x3e \\"Plock!\\"\\nend\\n\\nfunction Block:Destroy()\\n\\nend\\n```\\n\\n```lua\\n-- Server component\\nlocal Block = {Name = \\"Block\\", Tags = {\\"Block\\"}, Client = {}}\\n\\nfunction Block.new(instance)\\n\\t\\nend\\n\\nfunction Block.Client.Block()\\n\\treturn \'Plock!\'\\nend\\n\\nfunction Block:Destroy()\\n\\nend\\n```","params":[{"name":"class","desc":"","lua_type":"table"},{"name":"serverComponentName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"static","source":{"line":341,"path":"packages/Component/init.lua"}},{"name":"ObserveFromTags","desc":"Works the same as `Component.GetFromTags`,except returns a promise which is resolved with the valid component found\\nunder `timeout` seconds, if specified. If `timeout` is specified and a valid component was still not found, then the promise \\nwill reject with a `nil` value.\\n\\nFor e.g:\\n\\n```lua\\ntask.delay(2, function()\\n\\t-- Create component\\n\\tComponent.new(someClass)\\nend)\\n\\nComponent.ObserveFromTags({\\"Example\\"}, 5):andThen(function(component)\\n\\tprint(\\"Component found, \\", component.Name)\\nend):catch(function(errorMessage)\\n\\twarn(\\"Component not found under 5 seconds\\")\\nend)\\n\\n--\x3e \\"Component found!\\n```","params":[{"name":"tags","desc":"","lua_type":"tags"},{"name":"timeout","desc":"","lua_type":"number ?"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"static","source":{"line":392,"path":"packages/Component/init.lua"}},{"name":"new","desc":"Creates and binds a new component to `class`.\\n\\n| Required `class` members and methods     | Description                          |\\n| ----------- | ------------------------------------ |\\n| `Tags`   | An array of collection service tags (strings). |\\n| `.new`  | A constructor method which is called whenever an instance is added or found whose CollectionService tags match `Tags`. The instance is passed as the only argument to this method and is considered \\"bound\\" to the object returned by this method.  |\\n| `:Destroy` | A method which which is called on an object (returned by the constructor method) bound to an instance which no longer has matching tags.  |\\n| `Name` | A string, representing the name of the class.  |\\n| `Client` | A table, only required if the component should be accessed on the client. This table should only ever exist on a serverside component.  |\\n\\n:::note\\nIt is expected that the constructor method `.new` returns an object (a table which \\"inherits\\" from `class`). However, it is also\\nsafe to return nothing from the constructor method, however, it is undefined behavior to do this.\\n:::\\n\\n| Optional `class` lifecycle methods and members     | Description  |\\n| ----------- | ------------------------------------ |\\n| `.PreRenderUpdatePriority`  | An `EnumItem` used in calling the `PreRenderUpdate` method, learn more about it [here](https://developer.roblox.com/en-us/api-reference/function/RunService/BindToRenderStep).  |\\n| `.WhiteListedInstanceServices` | An array of all white listed services that an instance must be a descendant of before considering it\'s tags. |\\n| `.Init()` | A method which is called just after the creation of the component of the class. |\\n| `:Start()`  | A method which is called on an object just after it is created and returned from the constructor method.  |\\n| `:Stop()`     | A method which is called on an object bound to an instance whose CollectionService tags no longer matches `Tags`. |\\n| `:PostSimulationUpdate()`  | A method called every `RunService.Heartbeat` on an object. |\\n| `:PreSimulationUpdate()`  | A method called every `RunService.Stepped` on an object. |\\n| `:PreRenderUpdate()`  | A method called every `RunService.RenderStepped` on an object. |\\n\\n| Injected class members   | Description  |\\n| ----------- | ------------------------------------ |\\n| `Component`  | The reference to the global component class. This is member is injected before the `Init` method is called. This member will be unaccessible after the component of the class is destroyed. |\\n\\n| Injected object members   | Description  |\\n| ----------- | ------------------------------------ |\\n| `Instance`  | A reference to an instance (bound to an object) injected to the object. This member will be unnaccessible after the object is destroyed. |\\n\\nExample component class: \\n\\nAny part with the `Part` tag will have it\'s brick color change to green and smoothly rotate. Once the `Part` tag is removed, the part will no longer rotate and have it\'s brick color change to red. There are no\\nlimiations to how many parts can be binded to a component, which means you can have many parts with `Part` tag bound\\nto this funtionality of the class.\\n\\n```lua\\nlocal Part = {\\n\\tTags = {\\"Part\\"}, \\n\\tName = \\"Part\\",\\n}\\nPart.__index = Part\\n\\nlocal MAX_Y_ROTATION = 70\\n\\nfunction Part.new(part)\\n\\treturn setmetatable({}, {__index = Part})\\nend\\n\\nfunction Part:Start()\\n\\t-- self.Instance is the reference injected to this object\\n\\tself.Instance.BrickColor = BrickColor.Green()\\nend\\n\\nfunction Part:PostSimulationUpdate(deltaTime)\\n\\tself.Instance.CFrame *= CFrame.Angles(0, math.rad(MAX_Y_ROTATION) * deltaTime, 0)\\nend\\n\\nfunction Part:Stop()\\n\\tself.Instance.BrickColor = BrickColor.Red()\\nend\\n\\nfunction Part:Destroy()\\n\\t-- The instance no longer had the \\"Part\\" tag (either it was parented to `nil`, destroyed or just\\n\\t-- doesn\'t have it anymore), we can perform some cleanup..\\n\\n\\t-- You also don\'t have to do self.Instance = nil as it is redundant, because it is already done internally by\\n\\t-- the component class!\\nend\\n\\nreturn Part\\n```","params":[{"name":"class","desc":"","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":536,"path":"packages/Component/init.lua"}},{"name":"GetObjectFromInstance","desc":"Returns an object of the component bound to `instance`.","params":[{"name":"instance","desc":"","lua_type":"?"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"method","tags":["Component"],"source":{"line":571,"path":"packages/Component/init.lua"}},{"name":"Destroy","desc":"Destroys the component and renders it unusuable.\\n\\n:::warning \\nTrivial errors will occur if your code unintentionally works on a destroyed component, \\nonly call this method when you\'re done working with the component!\\n:::","params":[],"returns":[],"function_type":"method","tags":["Component"],"source":{"line":586,"path":"packages/Component/init.lua"}}],"properties":[{"name":"ActiveObjects","desc":"A dictionary of all active component objects.","lua_type":"table","readonly":true,"source":{"line":46,"path":"packages/Component/init.lua"}},{"name":"OnComponentAdded","desc":"A signal which is fired whenever a component is added. ","lua_type":"Signal <componentAdded : Component>","readonly":true,"source":{"line":53,"path":"packages/Component/init.lua"}},{"name":"OnComponentDestroyed","desc":"A signal which is fired whenever a component is destroyed.","lua_type":"Signal <componentDestroyed : Component>","readonly":true,"source":{"line":60,"path":"packages/Component/init.lua"}},{"name":"OnObjectAdded","desc":"A signal which is fired whenever an object is created and returned \\nthrough the constructor method of the class bound to the component.","lua_type":"Signal <objectAdded: table>","tags":["Component"],"readonly":true,"source":{"line":70,"path":"packages/Component/init.lua"}},{"name":"OnObjectDestroyed","desc":"A signal which is fired whenever an object of the class bound to the component\\nis destroyed.","lua_type":"Signal  <objectDestroyed: table>","tags":["Component"],"readonly":true,"source":{"line":80,"path":"packages/Component/init.lua"}},{"name":"Tags","desc":"The reference to the `Tags` table in the class bound to the component.","lua_type":"table","tags":["Component"],"readonly":true,"source":{"line":89,"path":"packages/Component/init.lua"}},{"name":"Name","desc":"The reference to the `Name` member in the class bound to the component.","lua_type":"string","tags":["Component"],"readonly":true,"source":{"line":98,"path":"packages/Component/init.lua"}}],"types":[],"name":"Component","desc":"A class which is used to bind instances to tags and extend their functionality. Components are like binders, but are\\nhandled differently.","source":{"line":38,"path":"packages/Component/init.lua"}}')}}]);