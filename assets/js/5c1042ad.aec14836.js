"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[680],{98147:function(e){e.exports=JSON.parse('{"functions":[{"name":"IsA","desc":"A method which returns a boolean indicating if `self` is a timer or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":87,"path":"packages/Timer/init.lua"}},{"name":"new","desc":"Creates and returns a new timer. If `initialBoost` is specified, it will be set to the timer\'s `Boost` member.","params":[{"name":"timer","desc":"","lua_type":"number"},{"name":"initialBoost","desc":"","lua_type":"number | nil"}],"returns":[{"desc":"","lua_type":"Timer"}],"function_type":"static","source":{"line":99,"path":"packages/Timer/init.lua"}},{"name":"Reset","desc":"Resets the timer.","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":132,"path":"packages/Timer/init.lua"}},{"name":"Start","desc":"Starts the timer.","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":141,"path":"packages/Timer/init.lua"}},{"name":"IsStopped","desc":"Returns a boolean indicating if the timer has stopped.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","tags":["Timer"],"source":{"line":166,"path":"packages/Timer/init.lua"}},{"name":"Pause","desc":"Pauses the timer.","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":175,"path":"packages/Timer/init.lua"}},{"name":"Unpause","desc":"Unpauses the timer.","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":184,"path":"packages/Timer/init.lua"}},{"name":"IsPaused","desc":"Returns a boolean indicating if the timer has being paused.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","tags":["Timer"],"source":{"line":194,"path":"packages/Timer/init.lua"}},{"name":"Destroy","desc":"Destroys the timer and makes it unusuable.\\n\\n:::warning\\nTrivial errors will occur if your code unintentionally works on a destroyed timer, only call this method when you\'re done working with the timer.\\n:::","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":208,"path":"packages/Timer/init.lua"}},{"name":"Stop","desc":"Stops the timer.","params":[],"returns":[],"function_type":"method","tags":["Timer"],"source":{"line":224,"path":"packages/Timer/init.lua"}}],"properties":[{"name":"Boost","desc":"A value which by default is `0` if there was no initial boost specified during the creation of the timer. This value is added to the delta time the timer is\\nupdated every approximate frame, so increasing it will lead to faster timer updates.","lua_type":"number","tags":["Timer"],"readonly":true,"source":{"line":50,"path":"packages/Timer/init.lua"}},{"name":"OnTick","desc":"A signal which is fired whenever the timer \\"ticks\\" (when started). \\n\\n```lua\\ntimer.OnTick:Connect(function(deltaTime)\\n\\twarn((\\"After %d seconds, tick!\\"):format(deltaTime))\\nend)\\n\\ntimer:Start()\\n```","lua_type":"Signal <deltaTime: number>","tags":["Timer"],"readonly":true,"source":{"line":67,"path":"packages/Timer/init.lua"}}],"types":[],"name":"Timer","desc":"Timers are objects designed to work like alarms and are used to run code\\nat a specific later time.\\n\\nFor e.g:\\n```lua\\nlocal timer = Timer.new()\\ntimer.OnTick:Connect(function(deltaTime)\\n\\twarn((\\"Approximately %d seconds have passed\\"):format(deltaTime))\\nend)\\n\\ntimer:Start()\\n```","source":{"line":40,"path":"packages/Timer/init.lua"}}')}}]);