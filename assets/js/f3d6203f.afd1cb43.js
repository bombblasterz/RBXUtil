"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[877],{13330:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new communication signal with the identifier of `identifier`.","params":[{"name":"identifier","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"CommunicationSignal"}],"function_type":"static","source":{"line":121,"path":"packages/Remote/CommunicationSignal/Server.lua"}},{"name":"GetSignal","desc":"Returns the communication signal whose identifier is `identifier`.","params":[{"name":"identifier","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"CommunicationSignal | nil"}],"function_type":"static","source":{"line":159,"path":"packages/Remote/CommunicationSignal/Server.lua"}},{"name":"IsA","desc":"A method which is used to check if `self` is a communication signal or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":181,"path":"packages/Remote/CommunicationSignal/Server.lua"}},{"name":"Bind","desc":"Binds and exposes a new key `key` with value `value` to the client. \\n\\n:::note\\n- Remote function limitations apply. For more information, see [Remote Functions and Events](https://developer.roblox.com/en-us/articles/Remote-Functions-and-Events).\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"RemoteSignal | RemoteProperty | function | boolean | string | number | Instance | table"}],"returns":[],"function_type":"method","tags":["CommunicationSignal"],"source":{"line":198,"path":"packages/Remote/CommunicationSignal/Server.lua"}},{"name":"Dispatch","desc":"A method which dispatches the communication signal.\\n\\nFor e.g:\\n\\n```lua\\nlocal signal = CommunicationSignal.new(\\"Signal\\")\\nsignal:Bind(\\"Table\\", {1,2,3})\\nlocal dispatched = signal:Dispatch()\\n\\n-- Normally to access members you would do:\\nprint(signal.Members.Table) --\x3e {1, 2, 3}\\n\\n-- Dispatched signal:\\nprint(dispatchedSignal.Table) --\x3e  {1, 2, 3} \\n```\\n\\n:::tip\\nThe dispatched signal will be updated as new members, remote signals or remote properties are binded. \\n:::","params":[],"returns":[{"desc":"","lua_type":"table"}],"function_type":"method","source":{"line":255,"path":"packages/Remote/CommunicationSignal/Server.lua"}},{"name":"Destroy","desc":"Destroys the communication signal and makes it unusable.\\n\\n:::warning \\nTrivial errors will occur if your code unintentionally works on a destroyed communication signal, only call this method when you\'re done working with it!\\n:::","params":[],"returns":[],"function_type":"method","tags":["ClientRemoteProperty"],"source":{"line":302,"path":"packages/Remote/CommunicationSignal/Server.lua"}}],"properties":[],"types":[],"name":"CommunicationSignal","desc":"Communication signals are used to expose members, methods, remote signals and remote properties\\nto the client in a much easier and abstracted fashion.\\n\\n```lua\\n-- On the server\\nlocal communicationSignal = CommunicationSignal.new(\\"SomeSignal\\")\\n\\n-- Bind method \\"Test\\" to the client:\\ncommunicationSignal:Bind(\\"Test\\", function(player)\\n\\treturn \\"Hey!\\"\\nend))\\n\\n-- Bind member \\"Bo\\" to the client:\\ncommunicationSignal:Bind(\\"Bo\\", {1, 2, 3})\\n\\n-- On the client\\nlocal communicationSignal = CommunicationSignal.GetSignal(\\"SomeSignal\\"):expect()\\n\\nprint(communicationSignal.Members.Test(\\"Hi\\")) --\x3e \\"Hey!\\"\\nprint( communicationSignal.Members.Bo) --\x3e {1, 2, 3}\\n```","realm":["Server"],"source":{"line":53,"path":"packages/Remote/CommunicationSignal/Server.lua"}}')}}]);