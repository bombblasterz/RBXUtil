"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[797],{66827:function(e){e.exports=JSON.parse('{"functions":[{"name":"IsA","desc":"A method which returns a boolean indicating if `self` is a client remote signal or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":54,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"new","desc":"Creates and returns a new client remote signal.","params":[],"returns":[{"desc":"","lua_type":"ClientRemoteSignal"}],"function_type":"static","source":{"line":64,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"IsBoundToServer","desc":"Returns a boolean indicating if the client remote signal is bound to a remote signal.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":82,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"BindToServer","desc":"","params":[],"returns":[],"function_type":"method","ignore":true,"source":{"line":90,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Connect","desc":"Same as `self._remote:Connect(callback)`.","params":[{"name":"callback","desc":"","lua_type":"function"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":102,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Fire","desc":"Same as `self._remote:FireServer(...)`.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":135,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Destroy","desc":"Destroys the client remote signal, renders it unusuable and cleans up everything.\\n\\n:::note\\nYou should only ever destroy the client remote signal once you\'re completely done working with it to avoid\\nunexpected behavior.\\n:::","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":151,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"CleanupConnections","desc":"Disconnects all connections created through `ClientRemoteSignal:Connect`.","params":[],"returns":[],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":161,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Wait","desc":"A method which yields the thread until the remote signal (that this client remote signal is bound to) is fired to the client.","params":[],"returns":[{"desc":"","lua_type":"..."}],"function_type":"method","yields":true,"source":{"line":176,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}}],"properties":[],"types":[],"name":"ClientRemoteSignal","desc":"Client remote signals are used internally by communication signals to expose remote signals to the client. For e.g,\\na remote signal can be representable on the client through a client remote signal bound to that\\nremote signal by a communication signal.\\n\\n```lua\\nlocal clientRemoteSignal = ...\\nclientRemoteSignal:Fire(\\"Hey server\\")\\n```\\n\\n:::note\\nRemote event limitations and behavior edge cases apply. For more information, see [Remote Functions and Events](https://developer.roblox.com/en-us/articles/Remote-Functions-and-Events).\\n:::","realm":["Client"],"source":{"line":37,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}}')}}]);