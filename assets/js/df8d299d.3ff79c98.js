"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[349],{29498:function(n){n.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new maid.","params":[],"returns":[{"desc":"","lua_type":"Maid"}],"function_type":"static","source":{"line":90,"path":"packages/Maid/init.lua"}},{"name":"IsA","desc":"A method which is used to check if the given argument is a maid or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":108,"path":"packages/Maid/init.lua"}},{"name":"AddTask","desc":"Adds a task for the maid to cleanup. `alias` can be specified for removing the added task easily\\nthrough `maid:RemoveTask(alias)`, this is useful when you want to remove a task but don\'t have a direct\\nreference to it.\\n\\n:::note\\nIf `table` is passed as a task, it must implement a `Destroy` or `Disconnect` method so that it can be cleaned up.\\n:::","params":[{"name":"task","desc":"","lua_type":"table | RBXScriptConnection | function | Instance"},{"name":"alias","desc":"","lua_type":"string ?"}],"returns":[{"desc":"","lua_type":"task"}],"function_type":"method","tags":["Maid"],"source":{"line":127,"path":"packages/Maid/init.lua"}},{"name":"GetTask","desc":"Returns an added task of `alias`, if found.","params":[{"name":"taskAlias","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","tags":["Maid"],"source":{"line":167,"path":"packages/Maid/init.lua"}},{"name":"RemoveTask","desc":"Removes the task from the maid and cleans it up the final time. \\n\\nFor e.g:\\n\\n```lua\\nlocal task = function() print(\\"Cleaned up\\") end\\nmaid:AddTask(task)\\nmaid:RemoveTask(task)\\n--\x3e \\"Cleaned up\\"\\n```","params":[{"name":"task","desc":"Can also be an alias of some task for easy removal","lua_type":"task | string"}],"returns":[],"function_type":"method","tags":["Maid"],"source":{"line":192,"path":"packages/Maid/init.lua"}},{"name":"Cleanup","desc":"Cleans up all the added tasks.\\n\\n| Task      | Cleanup procedure                          |\\n| ----------- | ------------------------------------ |\\n| `function`  | The function will be called.  |\\n| `table`     | A `Destroy` or `Disconnect` method in the table will be called. |\\n| `Instance`    | The instance will be destroyed. |\\n| `RBXScriptConnection`    | The connection will be disconnected. |","params":[],"returns":[],"function_type":"method","tags":["Maid"],"source":{"line":210,"path":"packages/Maid/init.lua"}},{"name":"Destroy","desc":"Destroys the maid and renders it unusuable and cleans up all added tasks. Also unlinks the maid from all instances\\nit was linked to.\\n\\nFor e.g:\\n\\n```lua\\nlocal _, connection = maid:LinkToInstance(instance)\\nprint(connection:IsConnected()) --\x3e true\\nmaid:Destroy()\\nprint(connection:IsConnected()) --\x3e false\\n```","params":[],"returns":[],"function_type":"method","tags":["Maid"],"source":{"line":230,"path":"packages/Maid/init.lua"}},{"name":"LinkToInstance","desc":"\\t\\n\\nLinks the given instance to the maid so that the maid will be destroyed once the instance has been parented to `nil`.\\nIf `callback` is specified, it will be called before destroying the maid (when the instance is parented to `nil`) and \\nif the function upon being called doesn\'t return a truthy value, the maid will not be destroyed.\\n\\nFor e.g:\\n\\n```lua\\nlocal instance = ... -- some instance parented to workspace\\nlocal maid = Maid.new()\\n\\nmaid:AddTask(function()\\n\\twarn(\\"cleaned up\\")\\nend)\\n\\nmaid:LinkToInstance(instance)\\ninstance.Parent = nil\\n-- Now the maid will cleanup as the instance is parented to nil.\\n```\\n\\nHere\'s an alternate case:\\n\\n```lua\\nlocal instance = ... -- some instance parented to workspace\\nlocal maid = Maid.new()\\n\\nmaid:AddTask(function()\\n\\twarn(\\"cleaned up\\")\\nend)\\n\\nmaid:LinkToInstance(instance, function()\\n\\treturn not instance:GetAttribute(\\"DontHaveTheMaidCleanedupYetPlease\\") \\nend))\\n\\ninstance:SetAttribute(\\"DontHaveTheMaidCleanedupYetPlease\\", true)\\ninstance.Parent = nil\\n-- The instance is parented to nil, but the maid hasn\'t cleaned up!\\n```\\n\\nA connection is returned which contains the following methods:\\n\\n| Methods      | Description                          |\\n| ----------- | ------------------------------------ |\\n| `Disconnect`  | The connection will be disconnected and the maid will unlink to the instance it was linked to.  |\\n| `IsConnected` | Returns a boolean indicating if the connection has been disconnected. |\\n\\nOnce the connection is disconnected, the maid will be unlinked from the instance.\\n\\n:::note\\nThe behavior of this method is bound to change once the [Destroying](https://developer.roblox.com/en-us/api-reference/event/Instance/Destroying)\\nevent is officially enabled. When that happens, the maid will check if the instance is destroyed rather than just\\nparented to `nil`.\\n:::","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"callback","desc":"","lua_type":"function ?"}],"returns":[{"desc":"","lua_type":"Instance"},{"desc":"","lua_type":"Connection"}],"function_type":"method","source":{"line":302,"path":"packages/Maid/init.lua"}}],"properties":[],"types":[],"name":"Maid","desc":"Maids track tasks and clean them when needed. They are used to manage\\nstate easier and encapsulate clean ups.\\n\\nFor e.g:\\n\\n```lua\\nlocal maid = Maid.new()\\nlocal connection = workspace.ChildAdded:Connect(function()\\n\\nend)\\nmaid:AddTask(connection)\\nmaid:Cleanup()\\nprint(connection.Connected) --\x3e false\\n```","source":{"line":41,"path":"packages/Maid/init.lua"}}')}}]);