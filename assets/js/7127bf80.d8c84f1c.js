"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[797],{66827:function(e){e.exports=JSON.parse('{"functions":[{"name":"IsA","desc":"A method which returns a boolean indicating if `self` is a client remote signal or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":52,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"new","desc":"Creates and returns a new client remote signal.","params":[],"returns":[{"desc":"","lua_type":"ClientRemoteSignal"}],"function_type":"static","source":{"line":62,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"IsBoundToServer","desc":"Returns a boolean indicating if the client remote signal is bound to a serverside remote signal.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":80,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"BindToRemote","desc":"","params":[],"returns":[],"function_type":"method","ignore":true,"source":{"line":88,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Connect","desc":"Same as `self._remote:Connect(callback)`.","params":[{"name":"callback","desc":"","lua_type":"function"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":110,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Fire","desc":"Same as `self._remote:FireServer(...)`.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":141,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Destroy","desc":"Destroys the client remote signal and makes it unusuable.\\n\\n:::note\\nThe client remote signal will also be destroyed if the remote signal it was bound to was destroyed.\\n:::","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["ClientRemoteSignal"],"source":{"line":156,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}},{"name":"Wait","desc":"A method which yields the thread until the remote signal (that this client remote signal is bound to) is fired on the server.\\n\\n:::tip\\n- Any threads yielded through this method which aren\'t resumed yet, will be resumed with a `nil` value if \\nthe client remote signal is destroyed.\\n\\n- This method will automatically return `nil` without yielding the thread if the remote signal (the one that this\\nclient remote signal is bound to) is destroyed.\\n\\nFor e.g:\\n\\n```lua\\n-- On the server:\\nremoteSignal:Destroy()\\n\\n-- On the client:\\nprint(remoteSignal:Wait()) --\x3e nil\\nprint(remoteSignal:Wait()) --\x3e nil\\nprint(remoteSignal:Wait()) --\x3e nil\\n```\\n:::","params":[],"returns":[{"desc":"","lua_type":"..."}],"function_type":"method","yields":true,"source":{"line":187,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}}],"properties":[],"types":[],"name":"ClientRemoteSignal","desc":"Client remote signals are used internally by communication signals to expose serverside remote signals to the client. For e.g,\\na remote signal on the server can only be representable on the client through a client remote signal bound to it through a communication signal.\\n\\n```lua\\ntask.spawn(function()\\n\\tprint(clientRemoteSignal:Wait()) --\x3e \\"yo\\"\\nend)\\n\\nclientRemoteSignal:Fire(\\"yo\\")\\n```","realm":["Client"],"source":{"line":34,"path":"packages/Remote/Client/ClientRemoteSignal.lua"}}')}}]);